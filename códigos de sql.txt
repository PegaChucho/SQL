
---------Video 4 ORDER BY----------

SELECT * FROM `productos` WHERE `PAÍSDEORIGEN`="ESPAÑA" AND (`FECHA` BETWEEN "2002-02-01" AND "2002-05-30") ORDER BY `NOMBREARTÍCULO` DESC 

SELECT `EMPRESA`,`DIRECCIÓN`,`POBLACIÓN` FROM `clientes` ORDER BY POBLACIÓN, DIRECCIÓN DESC


---------Video 5 consultas de agrupación----------

SELECT SECCIÓN, AVG(PRECIO) AS PROM_ARTICULOS FROM PRODUCTOS GROUP BY SECCIÓN HAVING SECCIÓN="DEPORTES" OR SECCIÓN="CONFECCIÓN" ORDER BY PROM_ARTICULOS 
### Después de un GROUP BY va un HAVING en lugar de un WHERE.

SELECT `POBLACIÓN`, COUNT(`CÓDIGOCLIENTE`) AS N_CLIENTES FROM clientes GROUP BY `POBLACIÓN`
### Las consultas de agrupamiento llevan forzosamente una columna de agrupación y otra de cálculo.

SELECT SECCIÓN, MAX(PRECIO) AS PRECIOMAX FROM `productos` GROUP BY SECCIÓN HAVING SECCIÓN="CONFECCIÓN"

SELECT `DIRECCIÓN`,`POBLACIÓN` AS RESIDENCIA,`TELÉFONO` FROM `clientes` ORDER BY POBLACIÓN DESC 

SELECT POBLACIÓN FROM `clientes` GROUP BY POBLACIÓN 
### Muestra las poblaciones de la tabla clientes.

---------Video 6 consultas de cálculo----------

SELECT `NOMBREARTÍCULO`,`SECCIÓN`,ROUND(`PRECIO`),ROUND(PRECIO*1.21) AS PRECIO_MAS_IVA FROM `productos` 

---------Video 7 union entre datos de varias tablas-----

SELECT * FROM productos WHERE SECCIÓN= "DEPORTES" UNION SELECT * FROM productosnuevos WHERE SECCIÓN= "DEPORTES DE RIESGO" 

SELECT * FROM productos WHERE PRECIO >500 UNION SELECT * FROM productosnuevos WHERE SECCIÓN= "ALTA COSTURA"

SELECT * FROM `productos` WHERE `SECCIÓN`="DEPORTES" UNION ALL SELECT * FROM productosnuevos 

---------Video 8 JOINS-----

SELECT clientes. `CÓDIGO CLIENTE`, POBLACIÓN , DIRECCIÓN, `NÚMERO DE PEDIDO`, pedidos.`CÓDIGO CLIENTE`, `FORMA DE PAGO` FROM clientes INNER JOIN pedidos ON clientes.`CÓDIGO CLIENTE` = pedidos.`CÓDIGO CLIENTE` WHERE POBLACIÓN = 'MADRID' 
### La columna que relaciona a las tablas "clientes" y "pedidos" es "codigo cliente" , por eso se usa esa en el inner joint`
### SI HAY ESPACIOS EN BLANCO EN EL NOMBRE DE ALGUNA COLUMNA HAY QUE PONER TODO EL NOMBRE ENTRE `` COMILLAS DIAGONALES

SELECT clientes. `CÓDIGO CLIENTE`, POBLACIÓN , DIRECCIÓN, `NÚMERO DE PEDIDO`, pedidos.`CÓDIGO CLIENTE`, `FORMA DE PAGO` FROM clientes LEFT JOIN pedidos ON clientes.`CÓDIGO CLIENTE` = pedidos.`CÓDIGO CLIENTE` WHERE POBLACIÓN = 'MADRID' AND pedidos.`CÓDIGO CLIENTE` IS NULL 
#MUESTRA A LOS CLIENTES QUE NO HAN HECHO PEDIDO (SI NO EXISTE SU CODIGO DE CLIENTE EN LA TABLA DE PEDIDOS)

---------Video 10 SUBCONSULTAS-----

SELECT NOMBREARTÍCULO, SECCIÓN FROM PRODUCTOS WHERE PRECIO > (SELECT AVG(PRECIO) FROM productos)

SELECT * FROM productos WHERE PRECIO > ALL (SELECT PRECIO FROM productos WHERE SECCIÓN  = "CERÁMICA")
###Devuelve los productos que sean mas caros que todos los articulos de ceramica

SELECT * FROM productos WHERE PRECIO > ANY (SELECT PRECIO FROM productos WHERE SECCIÓN  = "CERÁMICA")
###Devuelve los productos que sean mas caros que CUALQUIER artículo de ceramica

---------Video 11 SUBCONSULTAS II IN NOT IN-----

SELECT NOMBREARTÍCULO, PRECIO FROM PRODUCTOS WHERE CÓDIGOARTÍCULO IN (SELECT CÓDIGOARTÍCULO FROM PRODUCTOSPEDIDOS WHERE UNIDADES > 20)
SELECT NOMBREARTÍCULO, PRECIO FROM PRODUCTOS INNER JOIN PRODUCTOSPEDIDOS ON PRODUCTOS.CÓDIGOARTÍCULO = PRODUCTOSPEDIDOS.CÓDIGOARTÍCULO WHERE UNIDADES > 20
SELECT EMPRESA, POBLACIÓN FROM CLIENTES WHERE CÓDIGOCLIENTE NOT IN (SELECT CÓDIGOCLIENTE FROM PEDIDOS WHERE FORMADEPAGO= "TARJETA")
### IN y NOT IN  ayudan a crear una columna filtro para filtrar datos en una subconsulta sin necesidad que las tablas estén relacionadas.

---------Video 12 CONSULTAS DE ACCIÓN UPDATE-----

UPDATE PRODUCTOS SET SECCIÓN="DEPORTIVOS" WHERE SECCIÓN="DEPORTES" 
UPDATE PRODUCTOS SET PRECIO = PRECIO+10 WHERE SECCIÓN="DEPORTES"

CREATE TABLE clientes_madrid SELECT * FROM clientes WHERE POBLACIÓN= "MADRID" ### Para PHPMyAdmin
SELECT * INTO CLIENTES_MADRID FROM CLIENTES WHERE POBLACIÓN="MADRID" ### Para Access

---------Video 13 CONSULTAS DE ACCIÓN DELETE, PREDICADOS (DISTINCT, DISTINCTROW)-----

DELETE FROM CLIENTES_MADRID WHERE POBLACIÓN = "MADRID"
SELECT DISTINCT EMPRESA FROM CLIENTES INNER JOIN PEDIDOS ON CLIENTES.CÓDIGOCLIENTE = PEDIDOS.[CÓDIGO CLIENTE]
SELECT DISTINCTROW * FROM PRODUCTOS WHERE SECCIÓN ="FERRETERÍA"
###El DISTINCTROW sirve para ver si se repite toda la fila e ignorar los repetidos

DELETE DISTINCTROW CLIENTES.*, PEDIDOS.[CÓDIGO CLIENTE] FROM CLIENTES LEFT JOIN PEDIDOS ON CLIENTES.CÓDIGOCLIENTE = PEDIDOS.[CÓDIGO CLIENTE] WHERE (((PEDIDOS.[CÓDIGO CLIENTE]) Is Null));
INSERT INTO CLIENTES (`CÓDIGO CLIENTE`, EMPRESA, POBLACIÓN, TELÉFONO) SELECT `CÓDIGO CLIENTE`, EMPRESA, POBLACIÓN, TELÉFONO FROM clientes_madrid

---------Video 15 REFERENCIAS CRUZADAS-----

TRANSFORM COUNT(PRECIO) AS NUM_ARTÍCULOS
SELECT NOMBREARTÍCULO
FROM PRODUCTOS 
GROUP BY NOMBREARTÍCULO
PIVOT SECCIÓN

TRANSFORM COUNT(POBLACIÓN) AS TOTAL_FORMAPAGO
SELECT EMPRESA FROM PREVIA
GROUP BY EMPRESA
PIVOT [FORMA DE PAGO]
### Solo se puede hacer una tabla de ref cruzada de una sola tabla, por lo que para esté caso se hizo la tabla "PREVIA"

TRANSFORM SUM(PRECIO) AS TOTAL
SELECT [NOMBREARTÍCULO], [PAÍSDEORIGEN] FROM PRODUCTOS
GROUP BY [NOMBREARTÍCULO],  [PAÍSDEORIGEN]
PIVOT SECCIÓN

---------Video 16 DDL CREAR TABLAS----

CREATE TABLE PRUEBA (NOMBRE TEXT(20), APELLIDO TEXT(20), EDAD TINYINT, FECHA_NACIMIENTO DATE, CARNET BIT)
DROP TABLE PRUEBA
CREATE TABLE PRUEBA (ID_ALUMNO COUNTER, NOMBRE TEXT(20), APELLIDO TEXT(20), EDAD BYTE, FECHA_NACIMIENTO DATE, CARNET BIT) ###ACCESS

CREATE TABLE PRUEBA (ID_ALUMNO INT AUTO_INCREMENT, NOMBRE TEXT(20), APELLIDO TEXT(20), EDAD TINYINT, FECHA_NACIMIENTO DATE, CARNET BOOL, PRIMARY KEY (ID_ALUMNO)) 


---------Video 17 MODIFICAR TABLAS ALTER----

ALTER TABLE CLIENTES_MADRID ADD COLUMN FECHA_BAJA DATE
ALTER TABLE prueba ADD COLUMN POBLACIÓN VARCHAR(20) 
ALTER TABLE PRUEBA DROP COLUMN POBLACIÓN
ALTER TABLE CLIENTES_MADRID ADD COLUMN FECHA_BAJA TEXT(10) ### TEXT SOLO SIRVE EN ACCES, EN PHPMYADMIN ES VARCHAR

ALTER TABLE PRUEBA ALTER COLUMN LUGAR_NACIMIENTO SET DEFAULT "DESCONOCIDO"
ALTER TABLE PRUEBA ALTER COLUMN LUGAR_NACIMIENTO DROP DEFAULT 
ALTER TABLE PRODUCTOS_ACTUALIZADOS MODIFY NUEVO_PRECIO INT(6)### CAMBIA EL TIPO DE VALOR

---------Video 18 ÍNDICES----

CREATE TABLE EJEMPLO (DNI TEXT, NOMBRE TEXT, APELLIDO TEXT, EDAD BYTE, PRIMARY KEY (DNI)) ###INDICE DE CLAVE PRIMARIA, NO PERMITE DUPLICADOS
ALTER TABLE EJEMPLO ADD PRIMARY KEY (DNI)###agrega clave primaria

CREATE INDEX MIINDICE ON EJEMPLO (APELLIDO)###  CREA UN INDICE ORDINARIO (PERMITE DUPLICADOS Y VACÍOS)
CREATE UNIQUE INDEX MIINDICE ON EJEMPLO (APELLIDO) ### CREA UN INDICE ÚNICO (SIN DUPLICADOS Y PERMITE VACIOS)
CREATE UNIQUE INDEX MIINDICE ON EJEMPLO (NOMBRE, APELLIDO) ###CREA UN INDICE COMPUESTO

DROP INDEX MIINDICE ON EJEMPLO #BORRA EL ÍNDICE
ALTER TABLE EJEMPLO ADD PRIMARY KEY (DNI) ###AGREGA UNA CLAVE PRIMARIA
DROP INDEX Index_23B4DE5B_9C91_4042 ON EJEMPLO
ALTER TABLE EJEMPLO DROP CONSTRAIT Index_23B4DE5B_9C91_4042  ### HACE LO MISMO QUE EL DE ARRIBA
ALTER TABLE EJEMPLO DROP PRIMARY KEY ### EN MYSQL


---------Video 20 TRIGGERS I----

CREATE TABLE REG_PRODUCTOS (CÓDIGO_ARTÍCULO VARCHAR(25), NOMBRE_ARTÍCULO VARCHAR(30), PRECIO INT(4), INSERTADO DATETIME) 

CREATE TRIGGER PRODUCTOS_AI AFTER INSERT ON PRODUCTOS FOR EACH ROW INSERT INTO REG_PRODUCTOS(CÓDIGO_ARTÍCULO, NOMBRE_ARTÍCULO, PRECIO, INSERTADO) VALUES(NEW.CÓDIGOARTÍCULO, NEW.NOMBREARTÍCULO, NEW.PRECIO, NOW()) 
INSERT productos (CÓDIGOARTÍCULO, NOMBREARTÍCULO, PRECIO, PAÍSDEORIGEN) VALUES("AR75", "PANTALÓN", 50, "ESPAÑA")  ###MODIFICA LA TABLA PRODUCTOS Y GRACIAS AL TRIGGER TAMBIÉN SE MODIFICA LA TABLA REG_PRODUCTOS.

---------Video 21 TRIGGERS II----

CREATE TABLE PRODUCTOS_ACTUALIZADOS (ANTERIOR_CÓDIGOARTÍCULO VARCHAR(4), ANTERIOR_NOMBREARTÍCULO VARCHAR(25), ANTERIOR_SECCIÓN VARCHAR(15), 
ANTERIOR_PRECIO INT(4), ANTERIOR_IMPORTADO VARCHAR(15), ANTERIOR_PAÍSDEORIGEN VARCHAR(15), ANTERIOR_FECHA DATE, NUEVO_CÓDIGOARTÍCULO VARCHAR(4), 
NUEVO_NOMBREARTÍCULO VARCHAR(25), NUEVO_SECCIÓN VARCHAR(15), NUEVO_PRECIO INT(4), NUEVO_IMPORTADO VARCHAR(15), NUEVO_PAÍSDEORIGEN VARCHAR(15), NUEVO_FECHA DATE)

CREATE TRIGGER ACTUALIZA_PRODUCTOS_BU BEFORE UPDATE ON PRODUCTOS FOR EACH ROW INSERT INTO PRODUCTOS_ACTUALIZADOS (ANTERIOR_CÓDIGOARTÍCULO, ANTERIOR_NOMBREARTÍCULO , ANTERIOR_SECCIÓN , ANTERIOR_PRECIO, ANTERIOR_IMPORTADO , ANTERIOR_PAÍSDEORIGEN ,
 ANTERIOR_FECHA, NUEVO_CÓDIGOARTÍCULO , NUEVO_NOMBREARTÍCULO , NUEVO_SECCIÓN , NUEVO_PRECIO , NUEVO_IMPORTADO , NUEVO_PAÍSDEORIGEN , NUEVO_FECHA , USUARIO , F_MODIF) 
VALUES(OLD.CÓDIGOARTÍCULO, OLD.NOMBREARTÍCULO,OLD.SECCIÓN,OLD.PRECIO, OLD.IMPORTADO, OLD.PAÍSDEORIGEN, OLD.FECHA, NEW.CÓDIGOARTÍCULO, NEW.NOMBREARTÍCULO,NEW.SECCIÓN,NEW.PRECIO, NEW.IMPORTADO, NEW.PAÍSDEORIGEN, NEW.FECHA, CURRENT_USER(), NOW())

UPDATE PRODUCTOS SET PRECIO = "20" WHERE CÓDIGOARTÍCULO="AR07" ### A MI NO ME SALIÓ AL 100 YA QUE JUAN TENIA LOS PRECIOS SEPARADOS POR COMAS

---------Video 22 TRIGGERS III----
CREATE TRIGGER ELIMPROD_AD AFTER DELETE ON PRODUCTOS FOR EACH ROW INSERT INTO PROD_ELIMINADOS (C_ART, NOMBRE, PAÍS_ORIGEN, PRECIO, SECCIÓN) 
VALUES (OLD.CÓDIGOARTÍCULO, OLD.NOMBREARTÍCULO, OLD.PAÍSDEORIGEN, OLD.PRECIO, OLD.SECCIÓN) 

ALTER TABLE prod_eliminados ADD COLUMN (USUARIO VARCHAR(20), FECHA_MODIF DATE)

DROP TRIGGER IF EXISTS `ELIMPROD_AD`;CREATE DEFINER=`root`@`localhost` TRIGGER `ELIMPROD_AD` AFTER DELETE ON `productos` FOR EACH ROW INSERT INTO PROD_ELIMINADOS 
(C_ART, NOMBRE, PAÍS_ORIGEN, PRECIO, SECCIÓN, USUARIO, FECHA_MODIF) VALUES (OLD.CÓDIGOARTÍCULO, OLD.NOMBREARTÍCULO, OLD.PAÍSDEORIGEN, OLD.PRECIO, OLD.SECCIÓN, CURRENT_USER(), NOW()) 

DROP ELIMPROD_AD 

---------Video 23 PROCEDIMIENTOS ALMACENADOS----

CREATE PROCEDURE MUESTRA_CLIENTES()
	SELECT * FROM CLIENTES WHERE POBLACIÓN = "MADRID"

CREATE ACTUALIZA_PRODUCTOS(N_PRECIO VARCHAR(20), CODIGO VARCHAR(4))
	UPDATE PRODUCTOS SET PRECIO = N_PRECIO WHERE CÓDIGOARTÍCULO=CODIGO
CALL ACTUALIZA_PRODUCTOS("425","AR28")

---------Video 24 PROCEDIMIENTOS Y TRIGGERS----

DELIMITER //
CREATE PROCEDURE CALCUÑA_EDAD (ANIO_NACIMIENTO INT)
	
    BEGIN 
    
   		DECLARE ANIO_ACT INT DEFAULT 2020;
        
        DECLARE EDAD INT;
        
        SET EDAD= ANIO_ACT-ANIO_NACIMIENTO;
        
        SELECT EDAD; ##FUNCIONA COMO RETURN
    
    END;//
    
DELIMITER ;


DELIMITER $$

CREATE TRIGGER REVISA_PRECIO BEFORE UPDATE ON PRODUCTOS FOR EACH ROW 
	
    BEGIN
    
    	IF(NEW.PRECIO<0) THEN
        	SET NEW.PRECIO=0; #### O SET NEW.PRECIO=OLD.PRECIO; ASÍ DEJA EL VALOR QUE YA ESTABA


        ELSEIF (NEW.PRECIO>1000) THEN
        	SET NEW.PRECIO=1000;
        END IF;
        
    END;$$
    
DELIMITER ; 	

UPDATE PRODUCTOS SET PRECIO = -10 WHERE CÓDIGOARTÍCULO="AR01" 

---------Video 25 VISTAS----

CREATE VIEW ART_DEPORTES AS 
SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO FROM productos WHERE SECCIÓN = "DEPORTES"}

ALTER VIEW art_deportes AS SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO FROM productos WHERE SECCIÓN ="DEPORTIVOS"### MODIFICA LAS VISTAS

CREATE VIEW ART_CERAMICA AS
SELECT NOMBREARTÍCULO, SECCIÓN, PRECIO FROM productos WHERE SECCIÓN = "CERÁMICA"

DROP VIEW ART_CERÁMICA ### ELIMINA UNA VISTA
